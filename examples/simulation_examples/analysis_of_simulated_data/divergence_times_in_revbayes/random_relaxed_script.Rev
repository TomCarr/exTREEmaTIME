n_taxa <- data.ntaxa()
taxa <- data.taxa()
n_branches <- n_taxa*2 - 2

mvi = 0
mni = 0

###################

Q := fnJC(4)

###################

rho <- 1
root_time <- tree.rootAge()
speciation <- 3
extinction <- 0

timetree ~ dnBDP(lambda=speciation, mu=extinction, rho=rho, rootAge=root_time, samplingStrategy="uniform", condition="nTaxa", taxa=taxa)
timetree.setValue(tree)

moves[++mvi] = mvSubtreeScale(timetree, weight=5.0)
moves[++mvi] = mvNodeTimeSlideUniform(timetree, weight=15.0)
moves[++mvi] = mvTreeScale(tree=timetree, delta=1.0, weight=3.0, tune=true)
moves[++mvi] = mvTreeScale(tree=timetree, delta=0.1, weight=3.0, tune=true)
moves[++mvi] = mvTreeScale(tree=timetree, delta=0.01, weight=3.0, tune=true)

#############################################################################################################

p ~ dnExponential(10)
moves[++mvi] = mvScale(p, lambda=1.0, tune=true, weight=3.0)

clock_base ~ dnLnorm(ln(clock_means_means[z]) - ((clock_means_sds[z]^2)/2), clock_means_sds[z]) 
moves[++mvi] = mvScale(clock_base, lambda = 1, weight=2.0, tune=true)

rate_max ~ dnLnorm(ln(rate_max_means[z]) - ((rate_max_sds[z]^2)/2), rate_max_sds[z]) 
moves[++mvi] = mvScale(rate_max, lambda = 1, weight=2.0, tune=true)

rate_min ~ dnLnorm(ln(rate_min_means[z]) - ((rate_min_sds[z]^2)/2), rate_min_sds[z]) 
moves[++mvi] = mvScale(rate_min, lambda = 1, weight=2.0, tune=true)

for (i in n_branches:1) {
NoRateChangeProbability[i] := Probability(1-p)
clockRateMultiplier[i] ~ dnReversibleJumpMixture(1, dnUniform(rate_min,rate_max), NoRateChangeProbability[i] ) # parameter to multiply rate by, either equal to one or another value
if ( timetree.isRoot( timetree.parent(i) ) ) { #if the parent node of a branch is the root...
branch_rates[i] := clock_base * clockRateMultiplier[i]
} else {
branch_rates[i] := branch_rates[timetree.parent(i)] * clockRateMultiplier[i] #else it equals the rate of the parent branch times the multiplier
}
clockRateChange[i] := ifelse( clockRateMultiplier[i] == 1, 0, 1 ) #counting whether rate changes have occurred
moves[++mvi] = mvRJSwitch(clockRateMultiplier[i], weight=1.0)
moves[++mvi] = mvScale(clockRateMultiplier[i], lambda=0.1, weight=2.0)
}

numRateChanges := sum(clockRateChange)
mean_rt := mean(branch_rates)

#############################################################################################################

seq ~ dnPhyloCTMC(tree=timetree, Q=Q, branchRates=branch_rates, type="DNA")
seq.clamp(data)

#############################################################################################################

mymodel = model(timetree)

monitors[++mni] = mnModel(filename=output_files[z] + "model.log", printgen=100, separator = TAB)
monitors[++mni] = mnFile(filename=output_files[z] + "sampled_trees.trees", printgen=100, timetree)
monitors[++mni] = mnScreen(printgen=100)

mymcmc = mcmc(mymodel, monitors, moves, nruns=1)
mymcmc.burnin(generations=100000, tuningInterval=500)
mymcmc.run(generations=1000000)

###################

clear(monitors, moves, n_taxa, taxa, n_branches, Q, rho, root_time, extinction, speciation, timetree, branch_rates, seq)
